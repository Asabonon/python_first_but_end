"""
Функция open:
    открывает файл в указанном режиме
    f = open('my.txt', 'w')
    file — имя файла
    mode — режим
    encoding — кодировка

Режимы открытия mode:
    r — чтение
    w — запись, если файла нет, создается новый
    x — запись, если файла нет, ошибка
    a — дозапись
    b — двоичный режим
    + — открытие на чтение и запись

Запись текста в файл:
    write — записать строку в файл
    writelines — записать список строк в файл
    \n — символ конца строки

Чтение из файла:
    read — чтение всего файла
    for line in f: — чтение файла построчно
    readlines — чтение файла в список строк

Закрытие файла:
    После работы с файлом его необходимо закрывать.
    Открытые файлы тратят ресурсы системы.
    f.close().
    Если до close произойдет исключительная ситуация, 
файл не будет закрыт.
    Удобным вместо close() является использование with.

############
f = open('first.txt', 'r')

for line in f:
    # Так как в файл построчно записывался через символы \n
    print(line.replace('\n', '')) 

f.close()

with open('first.txt', 'r') as f:
    for line in f:
        print(line.replace('\n', ''))

print('end')
############

Типы строк в Python:
    str — обычные строки
    bytes — строки байт
    bytearray — изменяемая строка байт

############
s = 'Hello world'
print(type(s)) # Вывод: <class 'str'>
sb = b'Hello world'
print(type(sb)) # Вывод: <class 'bytes'>

print(s[1]) # Вывод: e
print(s[1]) # Вывод: 101 (индекс символа по таблице ASCII)
############

Действия со строками байт:
    индекс sb[0]
    срез sb[1:3]
    ...

Как строка хранится в памяти?:
    Любая информация хранится в памяти как набор 0 и 1.
    Строки не являются исключением.
    Каждому символу ставится в соответствие определенный код (число).
    Коды могут быть разные и зависят от кодировки.

Основные кодировки:
    ascii — американские символы.
    latin-1 — европейские символы.
    utf-8 — универсальная кодировка для большинства языков.
    Чем универсальнее кодировка, тем больше байт требуется для кодирования одного символа.

Перевод строки в байты (кодирование):
    'Hello world'.encode('utf-8').
    При переводе строки str в байты bytes указываем кодировку.
    Кодировка должна поддерживать символы нужного нам алфавита.

Перевод байт в строку (декодирование):
    sb.decode('utf-8').
    Указываем кодировку, которой мы кодировали строку.

Работа с файлом в режиме байтов:
    open('filename', 'wb') — режим записи байтов
    open('filename', 'rb') — режим чтения байтов
    параметр encoding определяет кодировку
    open('filename', 'w', encoding='utf-8')

Запись байтов в файл:
    f.write(b'some bytes') — файл открыт в режиме wb
    f.write('some str') — файл открыт в режиме w
    в любом случае информация хранится в виде нулей и единиц

Чтение байтов из файла:
    f.read() - файл открыт в режиме rb — читаем байты
    f.read() - файл открыт в режиме r — читаем строки

Сериализация:
    Процесс преобразования объекта в поток байтов 
для сохранения или передачи в память, базу данных или файл.
    Обратный процесс — десериализация.

Применение сериализации:
    сохранение объекта в файл
    сохранение объекта в базу данных
    передача объекта по сети
    ...

Способы записи объекта в файл:
    ручной (создание велосипеда)
    универсальный pickle

Ручной способ:
    {'name': 'Max', 'phones': [123, 345]}
    Как перевести такой объект (dict) в байты для сохранения в файл?
    Придумать способ приведения объекта к более простым.
    Придумать свой формат хранения.

Ручной способ (Недостатки):
    Не универсальный.
    При небольшом изменении объекта изменится весь алгоритм.
    Надо помнить, как мы делали сохранение, чтобы потом прочитать.
    Трудоемкий.

Модуль pickle:
    Сохраняет сложные объекты в файл. 
    Преобразует сложные объекты в байты.
    Встроен в Python.

pickle. Основные функции:
    dump — сохранение объекта в файл 
    dumps — преобразование объекта в байты
    load — загрузка объекта из файла
    loads — загрузка объекта из набора байт

#########
import pickle
person = {'name': 'Max', 'phones': [123, 456]}

with open('person.dat', 'wb') as f:
    pickle.dump(person, f) # ��$ странным образом

print('Объекст записан')

with open('person.dat', 'rb') as f:
    person = pickle.load(f)

print(person) # {'name': 'Max', 'phones': [123, 456]}
print('Объекст выписан')

#########


Формат json:
    JavaScript Object Notation.
    Текстовый формат обмена данными, основанный на JavaScript.
    Аналогичен набору словарей, списков, простых типов данных в Python.
    Является просто текстом (строкой).

Применение:
    хранение данных
    передача данных
    чаще всего используется в web-разработке 
для передачи данных по протоколу http

json в Python:
    Основные структуры Python схожи с форматом.
    Требуется только преобразование в строку и обратно.
    Этим занимается модуль json.
    import json.

json. Основные функции:
    dump — сохранение объекта в формате json в файл 
    dumps — преобразование объекта в json (в текст)
    load — загрузка объекта из файла
    loads — загрузка объекта из формата json (строки)

#####################
import json

friends = [
    {'name': 'Max', 'age': 23, 'phones': [123, 456]},
    {'name': 'Leo', 'age': 33}
]

print(type(friends)) # <class 'list'>

# Преобразование из объекта в json 
json_friends = json.dumps(friends)

print(json_friends)         # [{"name": "Max", "age": 23, "phones": [123, 456]}, {"name": "Leo", "age": 33}] 
print(type(json_friends))   # <class 'str'>

# Преобразование из json в объект
friends = json.loads(json_friends)

print(friends)         # [{"name": "Max", "age": 23, "phones": [123, 456]}, {"name": "Leo", "age": 33}] 
print(type(friends))   # <class 'list'>


with open('friends.json', 'w') as f:
    json_friends = json.dump(friends, f)
    # [{"name": "Max", "age": 23, "phones": [123, 456]}, {"name": "Leo", "age": 33}]
print('Объекст записан')

with open('friends.json', 'r') as f:
    friends = json.load(f)

print(friends)       # [{'name': 'Max', 'age': 23, 'phones': [123, 456]}, {'name': 'Leo', 'age': 33}]   
print(type(friends)) # <class 'list'>
#####################


Задача:
    Передать список любимых песен и их исполнителей своему другу, 
разработчику C#.

"""

""" 1: Создать модуль music_serialize.py. 
В этом модуле определить словарь для вашей любимой музыкальной группы, 
например:

my_favourite_group = {
'name': 'Г.М.О.',
'tracks': ['Последний месяц осени', 'Шапито'],
'Albums': [{'name': 'Делать панк-рок','year': 2016},
{'name': 'Шапито','year': 2014}]}

С помощью модулей json и pickle сериализовать данный словарь 
в json и в байты, вывести результаты в терминал. 
Записать результаты в файлы group.json, group.pickle соответственно. 
В файле group.json указать кодировку utf-8. """

# Пусть это будет модуль music_serialize.py
import json
import pickle

my_favourite_group = {
'name': 'Г.М.О.',
'tracks': ['Последний месяц осени', 'Шапито'],
'Albums': [{'name': 'Делать панк-рок','year': 2016}, {'name': 'Шапито','year': 2014}]
}

print(my_favourite_group)

j_group = json.dumps(my_favourite_group)
#print(j_group)

p_group = pickle.dumps(my_favourite_group)
#print(p_group)

with open('group.json', 'w', encoding='utf-8') as f:
    json.dump(my_favourite_group, f)

with open('group.pickle', 'wb') as f:
    pickle.dump(my_favourite_group, f)
